#include "main.h"
#include "sound.h"

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

/*

  ===MESSAGE===

If you're reading this message, then you got the src(source code) from the author or you decompiled the malware, right?
So I'm going to tell you something
Don't ever apply this malware!!!
Because this malware is based on hydrogen.
There is no good in applying it!

That's all.

*/

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

//Default GDI

DWORD WINAPI sound(LPVOID lpParam)
{
	while (1)
	{
		sound1();
		Sleep(30000);
		sound2();
		Sleep(30000);
		sound3();
		Sleep(30000);
		sound4();
		Sleep(30000);
		sound5();
		Sleep(30000);
		sound6();
		Sleep(30000);
		sound7();
		Sleep(30000);
	}
}

DWORD WINAPI garbled(LPVOID lpParam)
{
	int uVar1;
	HWND hWnd;
	int iVar2;
	uint uVar3;
	CHAR* lpString;
	CHAR local_9;
	do
	{
		iVar2 = 0;
		do
		{
			uVar1 = rdtsc();
			uVar3 = (uint)uVar1 ^ (uint)uVar1 << 0xd;
			uVar3 = uVar3 ^ uVar3 << 0x11;
			(&local_9)[iVar2] = (CHAR)((ulonglong)(uVar3 << 5 ^ uVar3) % 0x47);
			iVar2 = iVar2 + 1;
		} while (iVar2 < 0x46);
		lpString = &local_9;
		hWnd = GetForegroundWindow();
		SetWindowTextA(hWnd, lpString);
		Sleep(2500);
	} while (true);
}

DWORD WINAPI cursor(LPVOID lpParam)
{
	HDC desk = GetDC(0);
	CURSORINFO curinf;
	int x = GetSystemMetrics(0), y = GetSystemMetrics(1);
	while (1)
	{
		GetCursorInfo(&curinf);
		curinf.cbSize = sizeof(curinf);
		DrawIcon(desk, rand() % x, rand() % y, curinf.hCursor);
		Sleep(100);
	}
}

//GDI Designation

//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\//\\

//payload1

DWORD WINAPI gdi1(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			int randPixel = rand() % 25;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cy + j].r + j / 10) % 150, (prgbScreen[i * szScreen.cx + j].b * i / 1) % 250, int(sqrt(prgbScreen[i * szScreen.cy + j].b + t)) % 250);
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload2

DWORD WINAPI gdi2(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].r * i) % 500, (prgbScreen[i].r * j / 2) % 250, (prgbScreen[25].r + j / 2) % 250);
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(25);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload3

DWORD WINAPI gdi3(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].r * i) % 500, (prgbScreen[i].r + j / 2) % 250, (prgbScreen[25].r + j / 2) % 250);
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(25);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload4

DWORD WINAPI gdi4(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].r + i), (prgbScreen[i * szScreen.cx + j].r * j), (prgbScreen[i * szScreen.cx + j].b));
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload5

DWORD WINAPI gdi5(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;
		HDC desk = GetDC(0);
		int sw = GetSystemMetrics(0), sh = GetSystemMetrics(1);
		double moveangle = 0;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g * j) % 100, (prgbScreen[i * szScreen.cx + j].r * i), (prgbScreen[5].r + j / 5) % 250);
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(25);
			int ax = (int)(cos(moveangle) * 5), ay = (int)(sin(moveangle) * 5);
			BitBlt(desk, ax, ay, sw, sh, desk, 0, 0, SRCCOPY);
			moveangle = fmod(moveangle + M_PI / 16.f, M_PI * 2.f);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload6

DWORD WINAPI gdi6(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].r + i) % 500, (prgbScreen[i].r * j / 2) % 250, (prgbScreen[5].r + j / 1) % 250);
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload7

DWORD WINAPI gdi7(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].r * j) % 200, (prgbScreen[i].r * i / 2), (prgbScreen[3].r + j / 2));
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload8

DWORD WINAPI gdi8(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].r | j), (prgbScreen[i].r | i / 2), (prgbScreen[3].r + j / 2));
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload9

DWORD WINAPI gdi9(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | j), (prgbScreen[i].r | i), (prgbScreen[i * szScreen.cx + j].b + i / 50));
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload10

DWORD WINAPI gdi10(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;
		HDC desk = GetDC(0);
		int sw = GetSystemMetrics(0), sh = GetSystemMetrics(1);
		double moveangle = 0;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | j), (prgbScreen[i].r | i), (prgbScreen[i * szScreen.cx + j].r + i / 50));
				}
			}
			int ax = (int)(cos(moveangle) * 25), ay = (int)(sin(moveangle) * 0);
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			BitBlt(desk, ax, ay, sw, sh, desk, 0, 0, SRCCOPY);
			moveangle = fmod(moveangle + M_PI / 16.f, M_PI * 2.f);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload11

DWORD WINAPI gdi11(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | j), (prgbScreen[i].r | i), (prgbScreen[i * szScreen.cx + j].b = i)) + 5 + t;
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload12

DWORD WINAPI gdi12(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | j), (prgbScreen[i].r | i), (prgbScreen[i].rgb % 0x102) * 0x010101);
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(50);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload13

DWORD WINAPI gdi13(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | j), (prgbScreen[i].r | i), (prgbScreen[i].b > i / 50)) * t;
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload14

DWORD WINAPI gdi14(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | i) % 25, (prgbScreen[i].r | j) % 50, (prgbScreen[i].b > i / 50)) * t;
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload15

DWORD WINAPI gdi15(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			int randPixel = 5;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | j) / 8, (prgbScreen[i].r | i), (prgbScreen[i].b > i / 50)) + t;
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload16

DWORD WINAPI gdi16(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | i), (prgbScreen[i * szScreen.cy + j].r | j), (prgbScreen[i].b > i / 50)) * 25;
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload17

DWORD WINAPI gdi17(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | i / 10), (prgbScreen[i * szScreen.cx + j].g | j / 10), (prgbScreen[i * szScreen.cx + j].b > t));
				}
			}
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					int temp1 = (i + rand() % 10 - 5);
					if (temp1 < 0)
					{
						temp1 = -temp1;
					}
					int temp2 = (j + rand() % 10 - 5);
					if (temp2 < 0)
					{
						temp2 = -temp2;
					}
					prgbScreen[i * szScreen.cx + j].rgb = prgbScreen[(temp1 * szScreen.cx + temp2) % (szScreen.cx * szScreen.cy)].rgb;
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(100);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload18

DWORD WINAPI gdi18(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | i) % 5, (prgbScreen[i].r | j), (prgbScreen[i].b >> i / 50)) * t;
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(5);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload19

DWORD WINAPI gdi19(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | i / 10) % 256, (prgbScreen[i * szScreen.cx + j].b | j / 25) % 256, (prgbScreen[i * szScreen.cx + j].b > t) % 256);
				}
			}
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					int temp1 = (i + 2);
					if (temp1 < 0)
					{
						temp1 = -temp1;
					}
					int temp2 = (j + 10);
					if (temp2 < 0)
					{
						temp2 = -temp2;
					}
					prgbScreen[i * szScreen.cx + j].rgb = prgbScreen[(temp1 * szScreen.cx + temp2) % (szScreen.cx * szScreen.cy)].rgb;
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(250);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload20

DWORD WINAPI gdi20(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | i / 10) % 256, (prgbScreen[i * szScreen.cx + j].b | j / 25) % 256, (prgbScreen[i * szScreen.cx + j].b > t) % 256);
				}
			}
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					int temp1 = (i + 2);
					if (temp1 < 0)
					{
						temp1 = -temp1;
					}
					int temp2 = (j + 10);
					if (temp2 < 0)
					{
						temp2 = -temp2;
					}
					prgbScreen[i * szScreen.cx + j].rgb = prgbScreen[(temp1 * szScreen.cx + temp2) % (szScreen.cx * szScreen.cy)].rgb;
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(250);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

//payload21

DWORD WINAPI gdi21(LPVOID lpParam)
{
	while (1)
	{
		int Time = 10;
		int dwStartTime = Time;
		HDC hdcScreen = GetDC(NULL);
		POINT ptScreen = GetVirtualScreenPos();
		SIZE szScreen = GetVirtualScreenSize();

		BITMAPINFO bmi = { 0 };
		PRGBQUAD prgbScreen;
		HDC hdcTempScreen;
		HBITMAP hbmScreen;

		bmi.bmiHeader.biSize = sizeof(BITMAPINFO);
		bmi.bmiHeader.biBitCount = 32;
		bmi.bmiHeader.biPlanes = 1;
		bmi.bmiHeader.biWidth = szScreen.cx;
		bmi.bmiHeader.biHeight = szScreen.cy;

		hdcTempScreen = CreateCompatibleDC(hdcScreen);
		hbmScreen = CreateDIBSection(hdcScreen, &bmi, 0, (void**)&prgbScreen, NULL, 0);
		SelectObject(hdcTempScreen, hbmScreen);

		for (int i = 0; Time < (dwStartTime + Time); i++)
		{
			hdcScreen = GetDC(NULL);
			BitBlt(hdcTempScreen, 0, 0, szScreen.cx, szScreen.cy, hdcScreen, 0, 0, SRCCOPY);
			int t = i;
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					prgbScreen[i * szScreen.cx + j].rgb = RGB((prgbScreen[i * szScreen.cx + j].g | i), (prgbScreen[i].r | j), (prgbScreen[i * szScreen.cx + j].b + i));
				}
			}
			for (int i = 0; i < szScreen.cy; i++)
			{
				for (int j = 0; j < szScreen.cx; j++)
				{
					int temp1 = (i + rand() % 25);
					if (temp1 < 0)
					{
						temp1 = -temp1;
					}
					int temp2 = (j + 25);
					if (temp2 < 0)
					{
						temp2 = -temp2;
					}
					prgbScreen[i * szScreen.cx + j].rgb = prgbScreen[(temp1 * szScreen.cx + temp2) % (szScreen.cx * szScreen.cy)].rgb;
				}
			}
			BitBlt(hdcScreen, 0, 0, szScreen.cx, szScreen.cy, hdcTempScreen, 0, 0, SRCCOPY);
			ReleaseDC(NULL, hdcScreen);
			DeleteObject(hdcScreen);
			Sleep(100);
		}
		DeleteObject(hbmScreen);
		DeleteDC(hdcTempScreen);
		RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
		Sleep(1000);
	}
}

int WINAPI WinMain(HINSTANCE a, HINSTANCE b, LPSTR c, int d)
{
	//WARNING

	if (MessageBox(NULL, "!!!WARNING!!!\n\nYou have ran a Trojan known as PrgbquadBlend.exe that has full capacity to delete all of your data and your operating system.\n\nBy continuing, you keep in mind that the creator will not be responsible for any damage caused by this trojan and it is highly recommended that you run this in a testing virtual machine where a snapshot has been made before execution for the sake of entertainment and analysis.\n\nAre you sure you want to run this?", "PrgbquadBlend.exe - !!!WARNING!!! ", MB_ICONWARNING | MB_YESNO) != IDYES)
		exit(1);

	if (MessageBox(NULL, "!!!FINAL WARNING!!!\n\nThis Trojan has a lot of destructive potential. You will lose all of your data if you continue, and the creator will not be responsible for any of the damage caused. This is not meant to be malicious but simply for entertainment and educational purposes.\n\nAre you sure you want to continue?\nThis is your final chance to stop this program from execution.", "PrgbquadBlend.exe - !!!FINAL WARNING!!!", MB_ICONWARNING | MB_YESNO) != IDYES)
		exit(1);
	//Default GDI

	Sleep(2500);

	CreateThread(0, 0, sound, 0, 0, 0);
	CreateThread(0, 0, garbled, 0, 0, 0);
	CreateThread(0, 0, cursor, 0, 0, 0);
	
	HANDLE payload1 = CreateThread(0, 0, gdi1, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload1, 0);
	CloseHandle(payload1);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload2 = CreateThread(0, 0, gdi2, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload2, 0);
	CloseHandle(payload2);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload3 = CreateThread(0, 0, gdi3, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload3, 0);
	CloseHandle(payload3);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload4 = CreateThread(0, 0, gdi4, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload4, 0);
	CloseHandle(payload4);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload5 = CreateThread(0, 0, gdi5, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload5, 0);
	CloseHandle(payload5);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload6 = CreateThread(0, 0, gdi6, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload6, 0);
	CloseHandle(payload6);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload7 = CreateThread(0, 0, gdi7, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload7, 0);
	CloseHandle(payload7);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload8 = CreateThread(0, 0, gdi8, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload8, 0);
	CloseHandle(payload8);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload9 = CreateThread(0, 0, gdi9, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload9, 0);
	CloseHandle(payload9);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload10 = CreateThread(0, 0, gdi10, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload10, 0);
	CloseHandle(payload10);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload11 = CreateThread(0, 0, gdi11, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload11, 0);
	CloseHandle(payload11);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload12 = CreateThread(0, 0, gdi12, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload12, 0);
	CloseHandle(payload12);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload13 = CreateThread(0, 0, gdi13, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload13, 0);
	CloseHandle(payload13);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload14 = CreateThread(0, 0, gdi14, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload14, 0);
	CloseHandle(payload14);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload15 = CreateThread(0, 0, gdi15, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload15, 0);
	CloseHandle(payload15);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload16 = CreateThread(0, 0, gdi16, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload16, 0);
	CloseHandle(payload16);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload17 = CreateThread(0, 0, gdi17, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload17, 0);
	CloseHandle(payload17);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload18 = CreateThread(0, 0, gdi18, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload18, 0);
	CloseHandle(payload18);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload19 = CreateThread(0, 0, gdi19, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload19, 0);
	CloseHandle(payload19);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload20 = CreateThread(0, 0, gdi20, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload20, 0);
	CloseHandle(payload20);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	HANDLE payload21 = CreateThread(0, 0, gdi21, 0, 0, 0);
	Sleep(10000);
	TerminateThread(payload21, 0);
	CloseHandle(payload21);
	RedrawWindow(NULL, NULL, NULL, RDW_ERASE | RDW_INVALIDATE | RDW_ALLCHILDREN);
	//Sleep(10000); //GDI TESTING TIMER
	exit(1);
}